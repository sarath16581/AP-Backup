/**
 * @description Application module to handle task automation for opportunity owner.
 * @author Ranjeewa Silva
 * @date 2024-05-27
 * @Test OpportunityOwnerTasksModule_Test
 * @changelog
 * 2024-05-27 - Ranjeewa Silva - Created.
 */
public inherited sharing class OpportunityOwnerTasksModule extends ApplicationModule {

	// opportunity stages relevant for generating tasks for opportunity owner
	@TestVisible private static final Set<String> MONITORED_OPPORTUNITY_STAGES = new Set<String>{'Identify', 'Qualify'};

	// public groups identifying lead verification, sales managers and account manager users.
	@TestVisible private static final String LEAD_VERIFICATION_PUBLIC_GROUP = 'Lead_Vero_Group';
	@TestVisible private static final String SALES_MANAGERS_PUBLIC_GROUP = 'Sales_Managers';
	@TestVisible private static final String ACCOUNT_MANAGERS_PUBLIC_GROUP = 'Account_Managers';

	// opportunity ids enqueued for async work in current transaction.
	private static Set<Id> enqueuedOpportunityIds = new Set<Id>();

	// active users who are members of the public groups. group members are expanded for all 3 groups in one go.
	// when we check for group memberships, we'll always have to check for previous and new owner in either of the 3 groups.
	// public groups are expanded only in async worker to ensure opportunity save transaction is not impacted by this.
	private static Map<String, Set<Id>> publicGroupMembers {
		get {
			if (publicGroupMembers == null) {
				publicGroupMembers = GroupMembershipService.getInstance().expandGroupMembership(new Set<String>{
						LEAD_VERIFICATION_PUBLIC_GROUP, SALES_MANAGERS_PUBLIC_GROUP, ACCOUNT_MANAGERS_PUBLIC_GROUP
				}, new Set<GroupMembershipService.MemberTypes>{
						GroupMembershipService.MemberTypes.USER, GroupMembershipService.MemberTypes.ROLE, GroupMembershipService.MemberTypes.ROLE_AND_SUBORDINATES_INTERNAL
				});
			}
			return publicGroupMembers;
		}
		set;
	}

	// record type id of the tasks generated by this module.
	private static Id salesTaskRecordTypeId {
		get {
			if (salesTaskRecordTypeId == null) {
				salesTaskRecordTypeId = RecordTypesSelector.newInstance().selectByDeveloperName('Task', new Set<String>{'Sales_Task'}).values()[0].Id;
			}
			return salesTaskRecordTypeId;
		}
		set;
	}

	public OpportunityOwnerTasksModule() {
		getTriggerEvents().enableAfterUpdate();
	}

	public override void onAfterUpdate(List<SObject> records, Map<Id, SObject> existingRecords, ApplicationUnitOfWork uow) {

		try {
			// monitor opportunities changing owner. leverage ApplicationRecursion class to retrieve processable records
			// where the stage has been changed since the last execution of this module in a recursive update scenario.
			List<ApplicationRecursion.RecordState> changedRecords = ApplicationRecursion.getInstance().getProcessableRecords('OpportunityOwnerTasksModule', records, existingRecords, new Set<SObjectField>{
					Opportunity.OwnerId
			});


			// opportunities to process further to generate tasks for opportunity owners
			Map<Id, Opportunity> processableOpportunities = new Map<Id, Opportunity>();

			// iterate through the opportunities changing owner and identify opportunities originated from lead conversion
			// in 'Identify' / 'Qualify' stages. these opportunities need to be processed further (by async worker) to
			// determine if tasks are to be generated for opportunity owners. tasks are to be generated when opportunities
			// originated via lead conversion is:
			// - changing owner from lead verification team (public group 'Lead_Vero_Group') to sales manager (public group 'Sales_Managers')
			// - changing owner from sales manager (public group 'Sales_Managers') to account manager (public group 'Account_Managers')
			// expanding public groups to determine if opportunity owner belong to those groups and creating the tasks
			// are offloaded to an async operation.
			for (ApplicationRecursion.RecordState recordState : changedRecords) {
				Opportunity opportunityRecord = (Opportunity) recordState.record;

				// we also check if an async operation has been previously enqueued for this opportunity in current transaction.
				// this could happen in a recursive update scenario and in this case we only need to enqueue the opportunity
				// once for async work.
				if (MONITORED_OPPORTUNITY_STAGES.contains(opportunityRecord.StageName)
						&& String.isNotBlank(opportunityRecord.Lead_ID__c) && !enqueuedOpportunityIds.contains(opportunityRecord.Id)) {

					processableOpportunities.put(opportunityRecord.Id, opportunityRecord);
				}
			}

			if (!processableOpportunities.isEmpty()) {
				// we have identified the opportunities to be processed further. register async work for these records.
				// checking public group memberships of old and new opportunity owners are offloaded to async operation.
				registerAsyncWorkToCreateOpportunityOwnerTasks(processableOpportunities, (Map<Id, Opportunity>)existingRecords, uow);
			}
		} catch (Exception e) {
			ApplicationLogger.getInstance().logException(ApplicationLogger.wrapException(e), 'Sales', OpportunityOwnerTasksModule.class.getName(),
					'onAfterUpdate', String.valueOf(Opportunity.SObjectType), ApplicationLogger.LoggingLevel.ERROR);
		}
	}

	/**
	 * Register async workers to evaluate group memberships and create tasks.
	 *
	 * @param opportunities opportunities going through update operation
	 * @param existingOpportunities existing opportunities
	 * @param uow unit of work instance
	 */
	private void registerAsyncWorkToCreateOpportunityOwnerTasks(Map<Id, Opportunity> opportunities, Map<Id, Opportunity> existingOpportunities, ApplicationUnitOfWork uow) {
		Map<Id, CreateOpportunityOwnerTasksWorkerParam> asyncWorkerParams = new Map<Id, CreateOpportunityOwnerTasksWorkerParam>();
		for (Opportunity opportunity: opportunities.values()) {
			asyncWorkerParams.put(opportunity.Id, new CreateOpportunityOwnerTasksWorkerParam(opportunity.Id, existingOpportunities.get(opportunity.Id).OwnerId));
		}

		// enqueue async operation
		uow.registerAsyncWork(new ApplicationUnitOfWork.AsyncStagingWorker(OpportunityOwnerTasksModule.AsyncCreateOpportunityOwnerTasksWorker.class, asyncWorkerParams));
		enqueuedOpportunityIds.addAll(asyncWorkerParams.keySet());
	}

	/**
	 * Async worker to create tasks when converted opportunities move from lead verification team to sales managers and
	 * sales managers to account managers.
	 */
	public without sharing class AsyncCreateOpportunityOwnerTasksWorker extends ApplicationUnitOfWork.AsyncWorker {

		Map<Id, CreateOpportunityOwnerTasksWorkerParam> params = new Map<Id, CreateOpportunityOwnerTasksWorkerParam>();

		public override void execute(ApplicationUnitOfWork uow) {
			if (this.params != null && !this.params.isEmpty()) {
				// query opportunities to get the current opportunity owner.
				Map<Id, Opportunity> opportunities = ((OpportunitiesSelector)OpportunitiesSelector.newInstance().setFieldOverrides(new Set<SObjectField>{
						Opportunity.Id, Opportunity.OwnerId
				})).selectById(this.params.keySet());

				// mapping of opportunities assigned to account manager from sales manager to sales manager user id.
				// key - id of opportunity transferred to an account manager from sales manager
				// value - id of sales manager who owned the opportunity previously
				Map<Id, Id> accountManagerOpportunityToSalesManagerIdMapping = new Map<Id, Id>();

				for (CreateOpportunityOwnerTasksWorkerParam param: this.params.values()) {

					if (isMemberOfPublicGroup(param.previousOwnerId, LEAD_VERIFICATION_PUBLIC_GROUP)
							&& isMemberOfPublicGroup(opportunities.get(param.opportunityId).OwnerId, SALES_MANAGERS_PUBLIC_GROUP)) {
						// opportunity moving from lead verification team to sales manager. create new sales manager task assigned to new owner.
						Task newTask = newSalesTask(opportunities.get(param.opportunityId).OwnerId,
								param.opportunityId,
								Label.TransferNewlyAssignedOpportunitySalesManagerTaskSubject,
								Label.TransferNewlyAssignedOpportunitySalesManagerTaskDescription
						);
						uow.registerNew(newTask, false, OpportunityOwnerTasksModule.class.getName());
					} else if (isMemberOfPublicGroup(param.previousOwnerId, SALES_MANAGERS_PUBLIC_GROUP)
							&& isMemberOfPublicGroup(opportunities.get(param.opportunityId).OwnerId, ACCOUNT_MANAGERS_PUBLIC_GROUP)) {
						// opportunity is moving from sales manager to account manager. we need to check if we have
						// an existing task related to this opportunity assigned to sales manager.
						accountManagerOpportunityToSalesManagerIdMapping.put(param.opportunityId, param.previousOwnerId);
					}
				}

				if (!accountManagerOpportunityToSalesManagerIdMapping.isEmpty()) {
					// we have opportunities moving from sales manager to account manager. query existing sales manager
					// tasks related to these opportunities.
					Map<Id, Task> existingSalesManagerTasksForOpportunity = selectExistingSalesManagerTasks(accountManagerOpportunityToSalesManagerIdMapping);
					for (Id opportunityId: accountManagerOpportunityToSalesManagerIdMapping.keySet()) {
						Task salesManagerTask = existingSalesManagerTasksForOpportunity.get(opportunityId);
						// check for a sales manager task is existing for this opportunity. only need to create account manager task
						// for opportunities converted by lead verification team and transferred from sales manager to account manager.
						if (salesManagerTask != null) {
							// existing sales manager task found for this opportunity. create a new account manager task
							// assigned to new owner. if sales manager task is still open, mark it as completed as the opportunity
							// is now assigned to an account manager.
							Task newTask = newSalesTask(opportunities.get(opportunityId).OwnerId,
									opportunityId,
									Label.NewOpportunityForActionAccountManagerTaskSubject,
									Label.NewOpportunityForActionAccountManagerTaskDescription
							);
							uow.registerNew(newTask, false, OpportunityOwnerTasksModule.class.getName());
							if (!salesManagerTask.IsClosed) {
								uow.registerDirty(new Task(Id=salesManagerTask.Id, Status='Completed', ActivityDate=Date.today()), false, OpportunityOwnerTasksModule.class.getName());
							}
						}
					}
				}
			}
		}

		public override Type getClassType() {
			return CreateOpportunityOwnerTasksWorkerParam.class;
		}

		public override SObjectType getSObjectTypeGroup() {
			return Task.SObjectType;
		}

		public override void deserialiseParams(String serialisedParams) {
			if (!String.isEmpty(serialisedParams)) {
				this.params = (Map<Id, CreateOpportunityOwnerTasksWorkerParam>)JSON.deserialize(serialisedParams, Map<Id, CreateOpportunityOwnerTasksWorkerParam>.class);
			}
		}

		/**
		 * Check if the user is member of the public group. Only 'Lead_Vero_Group', 'Sales_Managers' or 'Account_Managers'
		 * are supported.
		 *
		 * @param userId User ID to check
		 * @param groupDeveloperName Public group developer name (Must be one of 'Lead_Vero_Group', 'Sales_Managers' or 'Account_Managers')
		 *
		 * @return true if user is a member of public group. false otherwise.
		 */
		private Boolean isMemberOfPublicGroup(Id userId, String groupDeveloperName) {
			if (publicGroupMembers.containsKey(groupDeveloperName)
					&& publicGroupMembers.get(groupDeveloperName).contains(userId)) {
				return true;
			}
			return false;
		}

		/**
		 * Select existing sales manager tasks related to the opportunities passed in, and assigned to the user ids passed in.
		 *
		 * @param opportunityIdPreviousOwnerIdMapping Related opportunity Ids (Task.WhatId) to Task Owner mapping
		 *
		 * @return Sales manager tasks
		 */
		private Map<Id, Task> selectExistingSalesManagerTasks(Map<Id, Id> opportunityIdPreviousOwnerIdMapping) {
			Map<Id, Task> results = new Map<Id, Task>();

			// query existing sales manager tasks related to opportunities. results are ordered by 'CompletedDateTime DESC NULLS First'
			Map<Id, Task> existingSalesManagerTasks = TasksSelector.newInstance(0, 0, Task.CompletedDateTime.toString(), 'DESC NULLS First', new Set<SObjectField>{
					Task.OwnerId, Task.IsClosed, Task.ActivityDate, Task.WhatId
			}).search(new Map<String, Object>{
					'whatIds' => opportunityIdPreviousOwnerIdMapping.keySet(),
					'subjects' => new Set<String>{Label.TransferNewlyAssignedOpportunitySalesManagerTaskSubject}
			}, new Set<Object>(), true);

			for (Task salesManagerTask: existingSalesManagerTasks.values()) {

				// check task owner is the previous owner for the opportunity.
				// we only need to grab the latest task for the opportunity (in case there are multiples).
				if ((!salesManagerTask.IsClosed || salesManagerTask.OwnerId == opportunityIdPreviousOwnerIdMapping.get(salesManagerTask.WhatId))
						&& !results.containsKey(salesManagerTask.WhatId)) {

					results.put(salesManagerTask.WhatId, salesManagerTask);
				}
			}

			return results;
		}

		private Task newSalesTask(Id ownerId, Id relatedToId, String subject, String description) {
			return new Task(
					RecordTypeId=salesTaskRecordTypeId,
					OwnerId=ownerId,
					WhatId=relatedToId,
					ActivityDate=Date.today().addDays(2),
					Type='Reminder',
					Status='Not Started',
					Priority='Normal',
					Subject=subject,
					Description=description
			);
		}
	}

	public class CreateOpportunityOwnerTasksWorkerParam {
		@TestVisible private Id opportunityId;
		@TestVisible private Id previousOwnerId;

		public CreateOpportunityOwnerTasksWorkerParam(Id opportunityId, Id previousOwnerId) {
			this.opportunityId = opportunityId;
			this.previousOwnerId = previousOwnerId;
		}
	}
}