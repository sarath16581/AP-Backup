/**************************************************
Description: This batch class is called while generating the proposal document from the proposal record
History:
2019-05-31 anshul.goyal@auspost.com.au Created | This apex class is the controller class for the vf page "APTS_CombineProposalDocs", which provided the merge doc functionality on the proposal record
2020-03-06 adishetty Modified | To accomodated the functionality of merging all proposal docs which are stored as Salesforce Files (ConentDocument) instead of Attachments. 
**************************************************
@ModifiedBy: Aditya Shetty
@ModifiedOn: 6 March, 2020
@Description: To accomodated the functionality of merging all proposal docs which are stored as Salesforce Files (ConentDocument) instead of Attachments
**************************************************/

public with sharing class APTS_CombineProposalDocsController {
    
	public ID attachID {get;set;} //ID of the attachment the user is interacting with
    public List<DocumentWrapper> attachmentWrappers{get; set;} //List of attachments and information to be displayed in the visualforce page
    public Boolean noAttachment {get;set;} //True if less than 1 attachment are retrieved
    public ID DocumentGeneratedbyMerge{get;set;}
  	//declaration of variables
    public List<ContentDocumentLink> lstAttachment = new List<ContentDocumentLink>(); //List of Attachments
    // Neccessary for controller extension
    public final Apttus_Proposal__Proposal__c APTSAgreementproposal;
    Apttus_Proposal__Proposal__c proposal = new Apttus_Proposal__Proposal__c(); //Agreement in use
    public Integer Sequence = 1; //Sequence of the attachments and initializating to 1
    public Boolean processSubmitted {get;set;} //True if merge document is clicked
    
    
    //Constructor
    public APTS_CombineProposalDocsController(ApexPages.StandardController stdController){

        List<ID> parsedDocGenbyMerge = new List<ID>(); //List of Attachment IDs that are generated by merging
        List<String> acceptableFormat = new List<String>{'doc', 'docx', 'pdf', 'rtf'}; //Only query files with these this prefix in their name
        attachmentWrappers = new list<DocumentWrapper>();
        processSubmitted = false;
        this.APTSAgreementproposal = (Apttus_Proposal__Proposal__c)stdController.getRecord();
        Id proposalID = Apexpages.currentPage().getParameters().get('Id');

        proposal = [SELECT ID, Name, RecordType.DeveloperName, Document_Generated_by_Merge__c,Apttus_Proposal__Account__r.name,Apttus_Proposal__Proposal_Name__c
                    FROM Apttus_Proposal__Proposal__c
                    WHERE ID = :proposalID
                    LIMIT 1];

        //Find the IDs of document generated by merge
        if(!String.isEmpty(proposal.Document_Generated_by_Merge__c)) {
            //Parse the IDs from Document_Generated_by_Merge__c
            List<String> tempParsedDocGenbyMerge = proposal.Document_Generated_by_Merge__c.split(';');

            for(String tempPDGbM : tempParsedDocGenbyMerge)
            {
                if(!String.isEmpty(tempPDGbM)) {
                    ParsedDocGenbyMerge.add(tempPDGbM);
                }
            }
        }

        
         /* Start: Aditya Shetty: Updated SOQL Query to get data from ContentDocumentLink instead of Attachment */
        lstAttachment = [SELECT ID,ContentDocument.Id,ContentDocument.Title FROM ContentDocumentLink
                        WHERE LinkedEntityId = :proposalID
                        AND ContentDocument.ID != :ParsedDocGenbyMerge
                        AND ContentDocument.FileExtension IN:acceptableFormat];
		/* End: Aditya Shetty: Updated SOQL Query to get data from ContentDocumentLink instead of Attachment */                       

        //If there are more than 1 attachment, set noAttachment to false
        if(lstAttachment.size() > 1){
            noAttachment = false;
        }
        else {
            noAttachment = true;
        }
        //If there are Attachments associated to this Agreement, put them into the Attachment Wrapper
        if(lstAttachment.size()>0){
            for(ContentDocumentLink attach : lstAttachment){
                
                /* Start: Aditya Shetty: Updated DocumentWrapper Arguments to get data from ContentDocumentLink instead of Attachment */
                if(Sequence == 1) { //Do not display the up button when it's the first item
                    attachmentWrappers.add(new DocumentWrapper(attach,attach.ContentDocument, proposal.Name, Sequence, false, true)); //, '1234', 'test status category', 'test status'
                }
                else if (Sequence == lstAttachment.size()) { //Do not display the down button when it's the last item
                    attachmentWrappers.add(new DocumentWrapper(attach,attach.ContentDocument, proposal.Name, Sequence, true, false));
                }
                else { //Display both buttons for other items
                    attachmentWrappers.add(new DocumentWrapper(attach,attach.ContentDocument, proposal.Name, Sequence, true, true));
                }
				/* End: Aditya Shetty: Updated DocumentWrapper Arguments to get data from ContentDocumentLink instead of Attachment */
                Sequence++;
            }
        }
    }
    
   	public void MergeInitialization() {
        processSubmitted = true;
    }
   
     //Merge the selected attachments
    public PageReference MergeDocument() {

        Apttus__ComplySystemProperties__c instanceurl = Apttus__ComplySystemProperties__c.getvalues('System Properties'); //Get the Instance URL

        map<Integer,ID> mapdocumentids = new map<Integer,ID>(); //Map for the Attachment IDs with Sequence as key
        Integer wrappersequence = 1; //Recount the sequence after removing not selected attachments
        //Save the ID of the attachment generated by merging

        //Parameters for merge API
        List<ID> lstDocumentIds = new List<ID>(); //List of Attachment IDs
//        String FileName = '_EMerged.pdf'; //Postfix file name for the merged document
        String FileName = ' '+proposal.Apttus_Proposal__Proposal_Name__c+' Proposal '+    
                          Date.today().year()+'-'+Date.today().month()+'-'+Date.today().day()+'_EMerged.pdf';
        String SESSION_ID = userInfo.getSessionId(); // Session Id
        /*Start Aditya Shetty: Updated the API version to 38.0 */
        String apiServerURL = instanceurl.Apttus__InstanceUrl__c +'/services/Soap/u/38.0/'+UserInfo.getOrganizationId(); //Merge Server URL
		/*End Aditya Shetty: Updated the API version to 38.0 */
        
        //Loop through lstWrapper and include the selected attachments
        for(DocumentWrapper wrapper : attachmentWrappers){
            if(wrapper.selected ){
                mapdocumentids.put(wrappersequence,wrapper.contentDoc.Id);
                wrappersequence++;
            }
        }

        //Throw an error if no attachment is selected
        if(mapdocumentids.size()==0) {
            ApexPages.addMessage(new ApexPages.Message(ApexPages.Severity.ERROR, 'No Documents Selected to merge'));
            return null; 
        }

        //Get the list of attachment IDs sort by sequence
        for(integer seq = 1; seq<=mapdocumentids.size(); seq++) {
            lstDocumentIds.add(mapdocumentids.get(seq));
        }

        //Call the merge API
        //merge doc
        try {
            Apttus.CustomClass.ActionParams objParam = new Apttus.CustomClass.ActionParams();
            objParam.SessionId = SESSION_ID;
            objParam.SessionUrl = apiServerURL;
            objParam.ParentId = proposal.Id;
            
            objParam.DocIds = lstDocumentIds;
            objParam.DocFileName = proposal.Name + FileName;
            objParam.AddFooter = false;
            //Avoid calling original webservice class in test run context
            system.debug('*** DocumentGeneratedbyMerge ***' + objParam);
            if(!Test.isRunningTest()){
             	DocumentGeneratedbyMerge = Apttus.MergeWebService.createPDF(objParam);   
            }
            
            system.debug('*** DocumentGeneratedbyMerge ***' + DocumentGeneratedbyMerge);
            //merge doc

            //Save the ID of the attachment generated by merging
            if (!String.isEmpty(DocumentGeneratedbyMerge)) {
                if (String.isEmpty(proposal.Document_Generated_by_Merge__c)) {
                    proposal.Document_Generated_by_Merge__c = DocumentGeneratedbyMerge + ';';
                }

                else {
                    proposal.Document_Generated_by_Merge__c = proposal.Document_Generated_by_Merge__c + DocumentGeneratedbyMerge + ';';
                }
                update proposal;
            }
        }
        catch(Exception exp) { // exception block to capture unhandled exception if any
            //Error Logged to Exception object for analysis
            UTIL_LoggingService.logHandledException(exp, UserInfo.getOrganizationId(), 'APTTUS',
                    'APTS_CombineProposalDocsController', 'MergeDocument', null, LoggingLevel.ERROR);
        }

        //Return to the record page
        Pagereference pageref = new pagereference('/'+proposal.Id);
        pageref.setredirect(true);
        return pageref;

    }
    
      //Return to the record page
    public PageReference Cancel() {
        Pagereference pageref = new pagereference('/'+proposal.Id);
        pageref.setredirect(true);
        return pageref;
    }

     //Action to move the attachment up
    public void upAction() {

        DocumentWrapper tempWrapper; //Temporary placeholder

        //Find the attachment that needs to be moved
        for(Integer i = 0; i < attachmentWrappers.size(); i++) {
            if(attachmentWrappers[i].contentDoc.Id == attachID) {

                //Do not do anything if the attachment is the first attachment
                if(attachmentWrappers[i].Sequence == 1) {
                    return;
                }

                //Swap the selected attachment with the attachment above it
                else {
                    try {
                        tempWrapper = attachmentWrappers[i];

                        attachmentWrappers[i].Sequence--;
                        attachmentWrappers[i - 1].Sequence++;

                        attachmentWrappers[i] = attachmentWrappers[i - 1];
                        attachmentWrappers[i - 1] = tempWrapper;

                        //Reevaluate upVisible and downVisible
                        for (Integer j = 0; j <= 1; j++) {
                            if (attachmentWrappers[i - j].Sequence == 1) {
                                attachmentWrappers[i - j].upVisible = false;
                            } else if (attachmentWrappers[i - j].Sequence == attachmentWrappers.size()) {
                                attachmentWrappers[i - j].downVisible = false;
                            } else {
                                attachmentWrappers[i - j].upVisible = true;
                                attachmentWrappers[i - j].downVisible = true;
                            }
                        }
                    }
                    catch(Exception exp) { // exception block to capture unhandled exception if any
                        //Error Logged to Exception object for analysis
                        UTIL_LoggingService.logHandledException(exp, UserInfo.getOrganizationId(), 'APTTUS',
                                'APTS_CombineProposalDocsController', 'upAction', null, LoggingLevel.ERROR);
                    }
                    return;
                }
            }
        }
    }

      //Action to move the attachment down
    public void downAction() {

        DocumentWrapper tempWrapper; //Temporary placeholder

        //Find the attachment that needs to be moved
        for(Integer i = 0; i < attachmentWrappers.size(); i++) {
            if(attachmentWrappers[i].contentDoc.Id == attachID) {

                //Do not do anything if the attachment is the last attachment
                if(attachmentWrappers[i].Sequence == attachmentWrappers.size()) {
                    return;
                }
                //Swap the selected attachment with the attachment below it
                else {
                    try {
                        tempWrapper = attachmentWrappers[i];

                        attachmentWrappers[i].Sequence++;
                        attachmentWrappers[i + 1].Sequence--;

                        attachmentWrappers[i] = attachmentWrappers[i + 1];
                        attachmentWrappers[i + 1] = tempWrapper;

                        //Reevaluate upVisible and downVisible
                        for (Integer j = 0; j <= 1; j++) {
                            if (attachmentWrappers[i + j].Sequence == 1) {
                                attachmentWrappers[i + j].upVisible = false;
                            } else if (attachmentWrappers[i + j].Sequence == attachmentWrappers.size()) {
                                attachmentWrappers[i + j].downVisible = false;
                            } else {
                                attachmentWrappers[i + j].upVisible = true;
                                attachmentWrappers[i + j].downVisible = true;
                            }
                        }
                    }
                    catch(Exception exp) { // exception block to capture unhandled exception if any
                        //Error Logged to Exception object for analysis
                        UTIL_LoggingService.logHandledException(exp, UserInfo.getOrganizationId(), 'APTTUS',
                                'APTS_CombineProposalDocsController', 'downAction', null, LoggingLevel.ERROR);
                    }
                    return;
                }
            }
        }
    }
    /*Start Aditya Shetty: Updated the DocumentWrapper properties to get values from ContentDocument instead of Attachment */ 
     public class DocumentWrapper{
        public ContentDocumentLink contentDocLink{get;set;}
        public ContentDocument contentDoc {get;set;}
        public String proposalName{get;set;}
        public Integer Sequence {get;set;}
        public boolean selected{get;set;}
        public boolean upVisible{get;set;}
        public boolean downVisible{get;set;}

        public DocumentWrapper(ContentDocumentLink contentDocLink,ContentDocument contentDoc, String proposalName, Integer Sequence,  boolean upVisible, boolean downVisible){
            this.contentDoc = contentDoc;
            this.contentDocLink = contentDocLink;
            this.proposalName = proposalName;
            this.Sequence = Sequence;
            this.upVisible = upVisible;
            this.downVisible = downVisible;
			
            this.selected = true; //Default to true
        }
      /*End Aditya Shetty: Updated the DocumentWrapper properties to get values from ContentDocument instead of Attachment */ 
}
}